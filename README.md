# my-shell

A simple shell (mini-bash) implemented in C as a semester project.

## Что было нужно реализовать (кратко)
- Интерактивный REPL со приглашением (prompt) и корректным выходом по `exit` или `Ctrl+D`.
- Лексер и парсер командной строки (поддержка кавычек, экранирования, токенизации).
- Выполнение внешних команд через `fork/exec`, встроенные команды (builtins).
- Перенаправления ввода/вывода: `>`, `>>`, `<`, `&>`, `&>>`.
- Конвейеры (pipes): `|` и `|&`.
- Операторы последовательности и управления: `;`, `&&`, `||`, `&`.
- Управление задачами (job control): фоновые задачи, `jobs`, `fg`, `bg`, `kill`.
- Корректное использование ресурсов: освобождение памяти, закрытие файловых дескрипторов.

## Что реализовано в этой ветке
- REPL с prompt `username@hostname:cwd ` и корректной обработкой `Ctrl+D`/`exit`.
- Лексер: обработка пробелов, кавычек (одинарных/двойных), экранирования и спецсимволов.
- Парсер: построение AST для команд, редиректов, пайпов, логических операторов и последовательностей.
- Выполнение:
	- Внешние команды через `fork/exec`.
	- Встроенные команды выполняются в процессе шелла.
	- Конвейеры (`|`) и `|&` (pipe stderr) реализованы.
	- Редиректы `>`, `>>`, `<`, `&>`, `&>>` реализованы с логикой "last-wins".
	- Операторы `;`, `&&`, `||`, `&` поддерживаются.
	- Job control: запуск в фоне (`&`), управление группами процессов, `jobs`, `fg`, `bg`, `kill`.
- Переменные: чтение/развертка переменных окружения (`$VAR`), установка/удаление переменных через `set`/`unset`.
- История и некоторые удобства: команда `history`, многострочный ввод и экранирование.
- Тесты: набор сценариев тестирования (в `Tests.md`) и валидация утечек памяти (valgrind) при ручном тестировании.

## Синтаксис — краткая памятка с примерами

- Простая команда:
	- ls -la /tmp

- Редиректы:
	- `cmd > out.txt` — stdout в `out.txt` (перезаписать).
	- `cmd >> out.txt` — stdout дописывается в `out.txt`.
	- `cmd < in.txt` — stdin берётся из `in.txt`.
	- `cmd &> both.txt` — stdout и stderr в `both.txt`.
	- Несколько редиректов: применяется последний. Пример:
		- `grep x -s > a.txt >> b.txt` — открываются `b.txt` и `a.txt` (оба), но итоговый stdout пойдёт в `b.txt`.

- Пайпы:
	- `cat file | grep foo | wc -l` — стандартный pipeline.
	- `cmd1 |& cmd2` — перенаправить stdout и stderr из `cmd1` в stdin `cmd2` (`|&`).

- Логические/последовательные операторы:
	- `cmd1 && cmd2` — выполнить `cmd2`, если `cmd1` успешна.
	- `cmd1 || cmd2` — выполнить `cmd2`, если `cmd1` неуспешна.
	- `cmd1 ; cmd2` — последовательно.
	- `cmd &` — выполнить в фоне.

- Subshell:
	- `(cmd1; cmd2) > out` — выполнить в подшелле.

- Переменные и присвоения:
	- `MYVAR=value` — установить переменную в контексте шелла.
	- `echo $MYVAR` — развернуть переменную.

## Как собрать и запустить
1. Собрать:

```
make
```

2. Запустить интерактивно:

```
make run
```

3. Выполнить скрипт/тестовый ввод (пример):

```
printf "echo hi > out.txt\nexit\n" | make run
```

## Тесты и проверка
- Основной файл тестов: `Tests.md` — содержит сценарии и отмеченные результаты.

## Известные проблемы / ограничения
- Режимы редиректов и порядок открытия файлов: файлы открываются при разборе редиректов; если нужен точный порядок обрезания/открытия, возможны небольшие расхождения от поведения GNU bash, но семантика "last-wins" соблюдена.
- При использовании редиректов, аргументы команды можно писать только после самой команды.

