# Job Control в bash — структурированное руководство



## 1. Введение — кто владеет терминалом и что такое группа процессов

- Процесс, которому принадлежит терминал (tty), формирует **переднюю группу процессов** (foreground process group).
- Когда `bash` читает и выполняет команду, эта команда (или конвейер) запускается **на переднем плане** — то есть в передней группе.
- До момента запуска дочернего процесса (`fork`/`exec`) команда исполняется под контролем `bash` в текущем терминале; после `exec` начинается выполнение внешней программы, которая уже выполняется в передней группе.

---

## 2. Поведение при приостановке и завершении передней группы

- Любые клавишные сигналы, которые вы отправляете (например, `Ctrl-C`, `Ctrl-Z`), ловит именно **передняя группа** — то есть процессы, находящиеся в ней.
- Как только такая группа приостанавливается или завершается:
  - `bash` **забирает терминал обратно** и вновь становится процессом, находящимся на переднем плане (владельцем терминала).
  - Если группа завершилась, `bash` обрабатывает её завершение (получает статус).
  - Если группа приостановилась, `bash` сохраняет информацию о ней (чтобы можно было возобновить позже).
- В обоих случаях `bash` снова получает управление терминалом и становится передним процессом в терминале.

---

## 3. Отличие фоновых задач от передних

- Что отличает фоновые (background) задачи:
  - `bash` **не ждёт** их завершения и **не отдаёт им терминал**.
  - Фоновые процессы выполняются без удержания терминала и не получают ввод с него, если только не были переведены на передний план.

---

## 4. Понятие Job (задача) и абстракция Job Control

- Потребуется отдельная структура — **Job**. Это абстракция исполнения, не то же самое, что внутреннее представление парсера:
  - Парсер (`bash` parser) — это внутреннее представление команд.
  - **Job** — абстракция исполнения тех команд/конвейеров.
- В рамках Job Control (механизма управления задачами) `bash` поддерживает эти абстракции, что особенно важно в интерактивном режиме (обычно `bash` интерактивен).

---

## 5. Интерактивный режим и скрипты

- Даже в скриптах часто встречаются условия, циклы и встроенные команды; поэтому концепция Job и Job Control полезна не только для интерактивного использования, но и для управления сложными сценариями исполнения.
- В интерактивном `bash` это особенно заметно — обычные команды и команды в скриптах по сути обрабатываются схожим образом, но Job Control даёт дополнительные возможности управления запущенными процессами.

---

## 6. Жизненный цикл Job и логика списка работ

- Когда вы запускаете программу/конвейер, появляется понятие **job**.
  - Если job выполняется на переднем плане, `bash` будет ждать её завершения; после завершения job обычно полностью обрабатывается и исчезает.
  - Если передняя задача не завершилась и была **приостановлена**, необходимо сохранить информацию о ней.
- Поэтому помимо структуры Job должна существовать коллекция всех текущих работ (список работ):
  - Это может быть массив или двусвязный список.
  - Двусвязный список часто удобнее, потому что операция удаления в произвольном месте списка — частая операция.
- Логика добавления в список:
  - Если работа, запущенная на переднем плане, **сразу** завершилась — нет смысла добавлять её в список работ.
  - Если же работа приостановилась — её **нужно добавить** в список, потому что в будущем её можно возобновить или завершить окончательно.
  - Если работа запускается **изначально в фоне** — она сразу добавляется в список работ, и `bash` дальше за ней следит.

---

## 7. Механизм проверки состояния работ

- Должна быть точка, где проверяются все существующие работы — например, в начале основного цикла обработки команд.
- На этой точке `bash` проходит по всем работам и с помощью **неблокирующего `wait`** ожидает изменения их статуса (например, `waitpid` с `WNOHANG` / `waitid`):
  - Процессы могут продолжиться (возобновиться), могут завершиться, могут быть приостановлены.
  - Вся полученная информация должна быть обработана и отражена в соответствующих флагах/полях структуры Job.
- Правило определения завершения job:
  - Работа считается завершённой, когда **все** её процессы завершились.
  - Если хотя бы один процесс работает (не приостановлен), то job ещё нужно оставлять в списке.
  - Когда job полностью завершена — её удаляют из списка текущих работ; история её исполнения (например, в `history`) может сохраняться отдельно.

---

## 8. Как соотносится «конвейер» и «job"

- В общем смысле **один конвейер** (pipeline) — это **одна job**.
- Если в командной строке вы объединяете несколько конвейеров/команд, вы по сути группируете процессы в job.
- Если у вас простая команда — это тоже job, но с одним процессом (конвейер из одного процесса).

---

## 9. Встроенные (builtin) команды и поведение `bash`

- **Встроенная команда** — это команда, которую `bash` реализует сам (внутренняя логика), а не запускает как внешнюю программу через `exec`.
- Последствия:
  - Встроенные команды **не исполняются** с помощью `exec`, они выполняются внутри процесса `bash`.
  - Поэтому при выполнении встроенных команд **не создаётся дочерний процесс** (нет `fork`) — за исключением специальных случаев (см. ниже).
- Исключения:
  - Если встроенная команда участвует в **конвейере** или запускается **в фоне**, то для неё создаётся **дочерний процесс**, и в нём выполняется встроенная команда.
    - Пример: если вы делаете `cd` в конвейере или в фоне, то `cd` выполнится в дочернем процессе, сменит директорию **только в этом дочернем процессе**, а директория `bash` не изменится.
    - Вы можете легко это протестировать — запустить `cd` в фоне или в конвейере, и директория `bash` останется прежней.
- Вывод: `bash` выполняет встроенные команды **сам** только в случае, когда они **не в фоне** и **не в конвейере**. Это единственный случай, когда выполнение встроенной команды меняет состояние самого `bash` (например, `cd`).

---

## 10. Поведение перенаправлений и пустых программ

- Если у вас пустая программа, но с перенаправлением ввода/вывода, то в зависимости от контекста может происходить форк (создание дочернего процесса) — детали поведения зависят от реализации `bash`.
- При отсутствии команды (пустая строка) с перенаправлением — простая команда не будет выполнена, если она фактически отсутствует.

---

## 11. Сигналы, обработчики и перевод задач между фоновой и передней группой

- При создании дочерних процессов им устанавливаются **дефолтные обработчики сигналов**:
  - Это нужно потому, что в любой момент фоновые процессы могут быть **переведены на передний план**.
  - Если при создании фоновых процессов им не сбросить обработчики сигналов в значения по умолчанию, то при переводе на передний план они могут неожиданно продолжать обрабатывать сигналы не так, как ожидает пользователь (например, не будут умирать при `Ctrl-C`).
- Поэтому при форке дочерних процессов `bash` обычно устанавливает для них дефолтные обработчики сигналов — чтобы поведение при переводе на передний план было корректным.

---

## 12. Встроенные команды, связанные с Job Control

- Существуют специальные встроенные команды, непосредственно связанные с Job Control:
  - `jobs` — распечатать список текущих работ.
  - `fg` / `bg` — перевести работу на передний / фоновый план:
    - `fg` без аргументов переводит в передний план **последнюю актуальную** работу.
    - `bg` переводит работу на фон.
    - Можно указывать работу либо по её **номеру** (job id), либо по **PID** (в зависимости от реализации и синтаксиса).
  - `kill` — послать сигнал:
    - Можно отправить сигнал по PID, по PGID (группе процессов) или по номеру работы.
  - `wait` — дождаться завершения фоновой работы.
  - `exec` — заменить текущий процесс `bash` другим процессом (выполнение без `fork`).
- Эти команды — ключ к управлению и контролю jobs в интерактивной оболочке.

---

## 13. Резюме и практические замечания

- Job Control — это слой абстракции поверх процессов и групп процессов, позволяющий:
  - сохранять состояние приостановленных задач;
  - управлять переводом задач между фоном и передним планом;
  - поддерживать список текущих работ для навигации и управления.
- Встроенные команды выполняются внутри `bash`, если они не находятся в конвейере и не запущены в фоне; в ином случае для них создаётся дочерний процесс.
- При проектировании внутренней структуры (в реализации оболочки) удобно хранить список работ в виде двусвязного списка, потому что часто происходит удаление работы из середины списка.
- Важные команды для пользователя: `jobs`, `fg`, `bg`, `kill`, `wait`, `exec`.

---

*Документ подготовлен автоматически на основе предоставленного текста и отредактирован для ясности и исправления опечаток.*

